<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="./logo.png" type="image/x-icon">
    <title>METODOS NUMERICOS</title>
    <script src="./js.js" type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.6.0/math.min.js"></script>

</head>
<body>
    <br>
    <br>
    <section id="portada">
        <div class="portada" align="center">
            <div class="encabezado">
                <img src="./fesa.png" alt="" class="logo">
                <div class="texto-centro">
                    <h1>UNAM</h1>
                    <h1>FES ACATLAN</h1>
                    <h2>Métodos Numéricos I</h2>
                </div>            
                <img src="FONDO.png" alt="" class="logo">
            </div>
            <br>
            <br>
            <div align="left">
                <h3>Integrantes:</h3>
                <br>
                <br>
                <br>
            </div>
            <div align="right">
                <h3>Fecha: <span id="fecha"></span></h3>
            </div>
            <button id="siguiente" class="boton">SIGUIENTE</button>
        </div>
    </section>
    <section id="introduccion">
        <div class="introduccion">
            <div align="center"><h1>INTRODUCCION</h1></div>   
            <br>         
            <p>Los <b>métodos numéricos</b> son técnicas matemáticas que permiten encontrar soluciones aproximadas a problemas matemáticos complejos, que no pueden ser resueltos de forma analítica o exacta. Se utilizan en diversos campos como la ingeniería, la física y la economía.</p>
            <h3>Aplicaciones de los Métodos Numéricos</h3>
            <p>Los métodos numéricos se aplican en muchos campos, incluyendo:</p>
            <ul>
                <li><strong>Simulación de sistemas físicos:</strong> En la ingeniería, para modelar fenómenos como el flujo de fluidos, la termodinámica, etc.</li>
                <li><strong>Optimización:</strong> En problemas donde se busca la mejor solución, como en la economía o la gestión de recursos.</li>
                <li><strong>Modelado matemático:</strong> En biología, química y otros campos para resolver ecuaciones diferenciales y algebraicas.</li>
            </ul>
            <h3>Conclusión</h3>
            <p>Los métodos numéricos son herramientas fundamentales para resolver problemas matemáticos complejos en aplicaciones del mundo real. La elección del método adecuado depende del tipo de problema, la precisión requerida y los recursos computacionales disponibles.</p>
            <div align="center">
                <button id="regresar" class="boton">REGRESAR</button>
                <button id="siguiente-2" class="boton">SIGUIENTE</button>
            </div>            
        </div>
    </section>
    <section id="menu-principal">
        <div class="menu-principal" align="center">
            <div align="center" class="menu-principal-2">
                <h1>Menú Principal</h1>
            </div>
            <br>
            <br>
            <div align="left">
                <p>Selecciona la unidad:</p>
            </div>
            <div align="left" class="opciones" class="radio">
                <label for="u-2" class="radio">UNIDAD II. Solución Numérica de Ecuaciones de una sola variable</label>
                <input type="radio" id="u-2" class="radio" name="rad">
                <br>
                <br>
                <label for="u-3" class="radio">UNIDAD III. Solución de sistemas de ecuaciones lineales</label>
                <input type="radio" id="u-3" class="radio" name="rad">
                <br>
                <br>
                <label for="u-4" class="radio">UNIDAD IV. Factorización LU y sus aplicaciones</label>
                <input type="radio" id="u-4" class="radio" name="rad">
                <br>
                <br>
                <label for="u-5" class="radio">UNIDAD V. Cálculo de valores y vectores propios</label>
                <input type="radio" id="u-5" class="radio" name="rad">
            </div> 
            <br>
            <br>
            <button id="regresar-2" class="boton">REGRESAR</button>
            <button id="seleccionar" class="boton">SELECCIONAR</button>
            <button id="salir" class="boton">SALIR</button>
        </div>
    </section>
            <!--UNIDAD II-->

    <div class="unidad-2">
        <section id="unidad-2-introduccion">
            <div class="introducciones">
                <div align="center">
                    <h2>Solución Numérica de Ecuaciones de una Variable</h2>
                </div>                
                <p>Los métodos numéricos para ecuaciones de una sola variable son técnicas matemáticas que permiten aproximar las raíces de una ecuación de la forma \( f(x) = 0 \). Estas raíces son los valores de \( x \) que satisfacen la ecuación. Dado que muchas ecuaciones no pueden resolverse de manera exacta, estos métodos son esenciales para encontrar soluciones en aplicaciones prácticas.</p>
            
                <h3>Características Generales</h3>
                <ul>
                    <li><strong>Aproximación iterativa:</strong> Los métodos numéricos suelen comenzar con una o más suposiciones iniciales y luego refinan estas aproximaciones a través de iteraciones.</li>
                    <li><strong>Requieren evaluación de la función:</strong> En cada iteración, se evalúa \( f(x) \) y, en algunos casos, su derivada o diferencias entre puntos.</li>
                    <li><strong>Convergencia:</strong> La velocidad con la que un método se aproxima a la raíz depende del método utilizado y de la cercanía de las suposiciones iniciales a la raíz real.</li>
                </ul>
            
                <h3>Clasificación de los Métodos</h3>
                <p>Los métodos numéricos para ecuaciones de una variable se pueden clasificar en dos categorías principales:</p>
                <ul>
                    <li><strong>Métodos cerrados:</strong> Trabajan en un intervalo cerrado \([a, b]\) donde \( f(a) \cdot f(b) < 0 \). Garantizan la existencia de al menos una raíz en el intervalo si la función es continua. Ejemplo: Método de Bisección.</li>
                    <li><strong>Métodos abiertos:</strong> No requieren un intervalo inicial, pero dependen de una o más aproximaciones iniciales. Su convergencia depende de la calidad de estas aproximaciones. Ejemplo: Métodos de Newton y de la Secante.</li>
                </ul>
            
                <h3>Importancia</h3>
                <p>Estos métodos son fundamentales en diversos campos de la ciencia y la ingeniería, ya que permiten resolver ecuaciones que surgen en problemas como:</p>
                <ul>
                    <li>El análisis de sistemas dinámicos.</li>
                    <li>La optimización de recursos en economía.</li>
                    <li>El diseño de estructuras en ingeniería.</li>
                    <li>El modelado de fenómenos naturales en física y química.</li>
                </ul>                        
                <h3>Conclusión</h3>
                <p>Los métodos numéricos para ecuaciones de una variable son herramientas esenciales para resolver problemas matemáticos complejos. Aunque tienen limitaciones, su implementación computacional permite abordar problemas que serían intratables mediante métodos analíticos tradicionales.</p>
                <div align="center">
                    <button id="regresar-u-2-1" class="boton">REGRESAR</button>
                    <button id="siguiente-u-2-1" class="boton">SIGUIENTE</button>
                </div>                
            </div>
        </section>
        <section id="unidad-2-menu">
            <div class="menu" align="center">
                <h2>Menú</h2>
                <h3>Solución Numérica de Ecuaciones de una sola variable</h3>
                <br>
                <br>
                <div align="center">
                    <br>
                    <br>
                    <table border="0" cellspacing="0" width="600px">
                        <tr>
                            <td align="center">
                                <label for="falsa-posicion" class="radio">TARTAGLIA</label>
                                <input type="radio" id="falsa-posicion" name="enl" class="radio">     
                            </td>
                            <td align="center">
                                <label for="newton" class="radio">NEWTON</label>
                                <input type="radio" id="newton" name="enl" class="radio">
                            </td>
                            <td align="center">
                                <label for="secante" class="radio">SECANTE</label>
                                <input type="radio" id="secante" name="enl" class="radio">
                            </td>
                        </tr>
                    </table>   
                    <br>
                    <br>                                                                        
                </div>              
                <br>
                <br>
                <button id="regresar-u-2-2" class="boton">REGRESAR</button>
                <button id="siguiente-u-2-2" class="boton">SELECCIONAR</button>
            </div>
        </section>
        <section id="falsa-posicion-1">
            <div class="metodos-1" align="center">
                <h1>Método de Falsa Posición</h1>
                <div align="justify">
                    <p>El método de falsa posición es un algoritmo para encontrar raíces de funciones continuas \( f(x) \), basado en la intersección de una línea recta con el eje \( x \). Se utiliza cuando existe un intervalo inicial \([a, b]\) donde \( f(a) \cdot f(b) < 0 \), asegurando la existencia de una raíz.</p>
                    
                    <h2>Fórmula</h2>
                    <p>La aproximación de la raíz \( c \) se calcula como:</p>
                    <p>
                        \[
                        c = b - \frac{f(b)(b - a)}{f(b) - f(a)}
                        \]
                    </p>

                    <h2>Pasos</h2>
                    <ol>
                        <li>Seleccionar un intervalo \([a, b]\) tal que \( f(a) \cdot f(b) < 0 \).</li>
                        <li>Calcular \( c \) y evaluar \( f(c) \).</li>
                        <li>Ajustar el intervalo: si \( f(c) \cdot f(a) < 0 \), reemplazar \( b \) con \( c \); de lo contrario, reemplazar \( a \) con \( c \).</li>
                        <li>Repetir hasta alcanzar el error deseado.</li>
                    </ol>

                    <h2>Aplicaciones</h2>
                    <p>Se utiliza en ingeniería, física y matemáticas para resolver ecuaciones no lineales, siendo más eficiente que el método de bisección en funciones casi lineales.</p>

                    <h2>Ventajas</h2>
                    <p>Es sencillo, garantiza convergencia y mejora la aproximación con cada iteración. Sin embargo, su convergencia puede ser lenta si la función tiene derivadas pequeñas cerca de los extremos del intervalo.</p>
                </div>
                <button id="regresar-u-2-f-p" class="boton">REGRESAR</button>
                <button id="siguiente-u-2-f-p" class="boton">SIGUIENTE</button>
            </div>
        </section>
        <section id="falsa-posicion-2">
            <div class="metodos-2" align="center">
                <h2>FALSA POSICIÓN</h2>
                <p>Instrucciones: Selecciona la ecuación y el intervalo para resolver con el método de Falsa Posición.</p>
                <div class="intervalo">
                    <p>Introduce el intervalo: \(x \in \) [</p>
                    <label for="inter-1"></label>
                    <input type="text" id="inter-1" class="inter">
                    <p>,</p>
                    <label for="inter-2"></label>
                    <input type="text" id="inter-2" class="inter">
                    <p>]</p>
                </div>                
                <div align="justify" class="ecuaciones">
                    <br>
                    <label for="ecuacion-1-f-p"> \( xe^x-x^3-3=0\)</label>
                    <input type="radio" id="ecuacion-1-f-p" class="radio" name="ecuaciones">
                    <div class="ec-2">
                        <label for="ecuacion-2-f-p"> \( x^2-e^x-3x+2=0\)</label>
                        <input type="radio" id="ecuacion-2-f-p" class="radio" name="ecuaciones">
                    </div>
                </div>
                <button id="resolver-f-p" class="boton-r">RESOLVER</button>
                <section id="solucion-fp">
                    <p>Por lo tanto  \(x \thickapprox \) <b><span id="sol-f-p"></span></b></p>                
                </section>
                <div id="tabla-f-p"></div>
                <br>
                <br>
                <br>
                <button id="regresar-u-2-f-p-2" class="boton">REGRESAR</button>
                <button id="salir-2" class="boton">SALIR</button>
            </div>
        </section>
        <section id="newton-1">
            <div class="metodos-1" align="center">
                <h1>Método de Newton</h1>
                <div align="justify">
                <p>El método de Newton, también llamado método de Newton-Raphson, es un algoritmo iterativo utilizado para encontrar aproximaciones a las raíces de funciones diferenciables \( f(x) \). Es rápido y eficiente, especialmente para funciones suaves cerca de la raíz.</p>

                <h2>Fórmula</h2>
                <p>Dado un valor inicial \( x_0 \), las aproximaciones sucesivas se calculan como:</p>
                <p>
                    \[
                    x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}
                    \]
                </p>

                <h2>Pasos</h2>
                <ol>
                    <li>Seleccionar un valor inicial \( x_0 \).</li>
                    <li>Calcular \( x_{n+1} \) usando la fórmula anterior.</li>
                    <li>Repetir hasta que \( |f(x_{n+1})| \) o la diferencia entre iteraciones sea menor que un umbral predefinido.</li>
                </ol>

                <h2>Aplicaciones</h2>
                <p>El método de Newton se utiliza ampliamente en ingeniería, física y matemáticas para resolver ecuaciones no lineales, optimización y problemas de ajuste de curvas.</p>

                <h2>Ventajas</h2>
                <p>Es rápido y, en general, converge cuadráticamente cerca de la raíz.</p>

                <h2>Limitaciones</h2>
                <p>Requiere conocer la derivada de \( f(x) \) y puede no converger si el valor inicial está lejos de la raíz o si \( f'(x) = 0 \) en algún punto del proceso.</p>
                </div>
                <button id="regresar-u-2-n" class="boton">REGRESAR</button>
                <button id="siguiente-u-2-n" class="boton">SIGUIENTE</button>
            </div>
        </section>
        <section id="newton-2">
            <div class="metodos-2" align="center">
                <h2>NEWTON</h2>
                <div align="center" >
                    <p>Instrucciones: Selecciona la ecuación a resolver y el valor inicial:</p>
                    <div class="intervalo" align="center">                        
                        <p>Valor inicial: </p>
                        <label for="valor-inicial"></label>
                        <input type="text" id="valor-inicial" class="inter">
                    </div>                    
                    <div align="justify" class="ecuaciones">
                        <br>
                        <label for="ecuacion-1-n"> \( x sen x+2x^2-1=0\)</label>
                        <input type="radio" id="ecuacion-1-n" class="radio" name="ecuaciones">
                        <div class="ec-2">
                            <label for="ecuacion-2-n"> \( x^2-e^x-3x+2=0\)</label>
                            <input type="radio" id="ecuacion-2-n" class="radio" name="ecuaciones">
                        </div>
                    </div>
                    <button id="resolver-n" class="boton-r">RESOLVER</button>
                    <br>
                    <br>
                    <section id="solucion-n">
                        <p>Por lo tanto \(x \thickapprox \) <b><span id="sol-n"></span></b></p>
                    </section>                    
                    <br>
                    <br>                    
                    <div id="tabla-n">
                    </div>
                    <br>
                    <br>
                </div>
                <button id="regresar-u-2-n-2" class="boton">REGRESAR</button>
                <button id="salir-3" class="boton">SALIR</button>
            </div>
        </section>
        <section id="secante-1">
            <div class="metodos-1" align="center">
                <h1>Método de la Secante</h1>
                <div align="justify">
                    <p>El método de la secante es un algoritmo iterativo utilizado para encontrar aproximaciones de las raíces de una función \( f(x) \). A diferencia del método de Newton, no requiere calcular derivadas, utilizando en su lugar una aproximación lineal basada en dos puntos.</p>
                
                    <h2>Fórmula</h2>
                    <p>Usando dos valores iniciales \( x_0 \) y \( x_1 \), la siguiente iteración \( x_{n+1} \) se calcula como:</p>
                    <p>
                        \[
                        x_{n+1} = x_n - f(x_n) \cdot \frac{x_n - x_{n-1}}{f(x_n) - f(x_{n-1})}
                        \]
                    </p>
                
                    <h2>Pasos</h2>
                    <ol>
                        <li>Seleccionar dos puntos iniciales \( x_0 \) y \( x_1 \).</li>
                        <li>Calcular \( x_{n+1} \) usando la fórmula.</li>
                        <li>Repetir el proceso hasta que \( |f(x_{n+1})| \) sea suficientemente pequeño o la diferencia entre iteraciones sea menor a un valor tolerable.</li>
                    </ol>
                
                    <h2>Ventajas</h2>
                    <ul>
                        <li>No requiere derivadas, a diferencia del método de Newton.</li>
                        <li>Puede converger más rápido que otros métodos como el de bisección.</li>
                    </ul>
                
                    <h2>Limitaciones</h2>
                    <ul>
                        <li>No siempre converge si los puntos iniciales no están cerca de la raíz.</li>
                        <li>Falla si \( f(x_n) - f(x_{n-1}) = 0 \).</li>
                    </ul>
                
                    <h2>Aplicaciones</h2>
                    <p>El método de la secante se usa ampliamente en ingeniería, física y matemáticas para resolver ecuaciones no lineales cuando el cálculo de derivadas no es práctico o posible.</p>
                </div>
                <button id="regresar-u-2-s" class="boton">REGRESAR</button>
                <button id="siguiente-u-2-s" class="boton">SIGUIENTE</button>
            </div>
        </section>
        <section id="secante-2">
            <div class="metodos-2" align="center">
                <h2>SECANTE</h2>
                <div align="center" >
                    <p>Instrucciones: Selecciona la ecuación a resolver y el valor inicial:</p>
                    <div class="intervalo" align="center">                        
                        <p>Valor inicial: </p>
                        <label for="valor-inicial-2"></label>
                        <input type="text" id="valor-inicial-2" class="inter">
                    </div>                    
                    <div align="justify" class="ecuaciones">
                        <br>
                        <label for="ecuacion-1-s"> \( x sen x+2x^2-1=0\)</label>
                        <input type="radio" id="ecuacion-1-s" class="radio" name="ecuaciones">
                        <div class="ec-2">
                            <label for="ecuacion-2-s"> \( x^2-e^x-3x+2=0\)</label>
                            <input type="radio" id="ecuacion-2-s" class="radio" name="ecuaciones">
                        </div>
                    </div>
                    <button id="resolver-s" class="boton-r">RESOLVER</button>
                    <br>
                    <br>
                    <section id="solucion-s">
                        <p>Por lo tanto \(x \thickapprox \) <b><span id="sol-s"></span></b></p>
                    </section>                    
                    <br>
                    <br>                    
                    <div id="tabla-s">
                    </div>
                    <br>
                    <br>
                </div>
                <button id="regresar-u-2-s-2" class="boton">REGRESAR</button>
                <button id="salir-4" class="boton">SALIR</button>
            </div>
        </section>   
    </div>
    <div class="unidad-3" align="center">
        <section id="unidad-3-introduccion">
            <div class="introducciones">
                <div align="center"><h1>Solución de sistemas de ecuaciones lineales</h1></div>                
                <br>
                <p>Los sistemas de ecuaciones lineales son conjuntos de ecuaciones de la forma:</p>
                <p>
                    \[
                    A \mathbf{x} = \mathbf{b}
                    \]
                    donde:
                    <ul>
                        <li>\( A \) es una matriz de coeficientes (\( n \times n \)).</li>
                        <li>\( \mathbf{x} \) es el vector de incógnitas (\( n \times 1 \)).</li>
                        <li>\( \mathbf{b} \) es el vector de términos independientes (\( n \times 1 \)).</li>
                    </ul>
                </p>
                <p>Los métodos numéricos para resolver estos sistemas son fundamentales en muchas aplicaciones prácticas donde el número de ecuaciones puede ser muy grande y los métodos analíticos son inviables.</p>

                <h3>Clasificación de los Métodos</h3>
                <p>Los métodos numéricos para sistemas de ecuaciones lineales se clasifican en:</p>
                <ul>
                    <li><strong>Métodos directos:</strong> Encuentran la solución exacta (o con error de redondeo) en un número finito de pasos. Ejemplo: Eliminación de Gauss.</li>
                    <li><strong>Métodos iterativos:</strong> Encuentran aproximaciones sucesivas a la solución. Son útiles para sistemas grandes y dispersos. Ejemplos: Método de Jacobi, Método de Gauss-Seidel.</li>
                </ul>
                <h3>Aplicaciones</h3>
                <p>Los métodos numéricos para sistemas de ecuaciones lineales se aplican en múltiples áreas, como:</p>
                <ul>
                    <li>Análisis estructural en ingeniería.</li>
                    <li>Modelado de circuitos eléctricos.</li>
                    <li>Simulación de fluidos en dinámica de fluidos computacional (CFD).</li>
                    <li>Resolución de problemas de optimización.</li>
                </ul>
                <h3>Conclusión</h3>
                <p>Los métodos numéricos para sistemas de ecuaciones lineales son herramientas esenciales en la resolución de problemas complejos en ciencia e ingeniería. La elección entre métodos directos e iterativos depende del tamaño del sistema, la naturaleza de la matriz \( A \) y los recursos computacionales disponibles.</p>
                <br>
                <div align="center">
                    <button id="regresar-u-3-1" class="boton">REGRESAR</button>
                    <button id="siguiente-u-3-1" class="boton">SIGUIENTE</button>
                </div>
            </div>
        </section>
        <section id="unidad-3-menu">
            <div class="menu">
                <h2>Menú</h2>
                <h3>Solución de sistemas de ecuaciones lineales</h3>
                <br>
                <br>
                <br>
                <br>
                <div align="left" class="m-u-3">         
                    <div>                                   
                        <label for="gauss-jordan" class="radio">GAUSS JORDAN</label>
                        <input type="radio" id="gauss-jordan" name="enl" class="radio">
                    </div>                 
                    <div>
                        <label for="jacobi" class="radio">JACOBI</label>
                        <input type="radio" id="jacobi" name="enl" class="radio">
                    </div>   
                    <div>
                        <label for="gauss-seidel" class="radio">GAUSS-SEIDEL</label>
                        <input type="radio" id="gauss-seidel" name="enl" class="radio">
                    </div>                    
                    <br>
                </div>
                <br>
                <br>
                <br>
                <br>
                <button id="regresar-u-3-2" class="boton">REGRESAR</button>
                <button id="siguiente-u-3-2" class="boton">SELECCIONAR</button>
            </div>            
        </section>
        <section id="gauss-jordan-1">
            <div class="metodos-1">
                <h1>Método de Gauss-Jordan</h1>
                <div align="justify">
                    <p>El método de Gauss-Jordan es un procedimiento algebraico utilizado para resolver sistemas de ecuaciones lineales y encontrar la inversa de una matriz. Es una extensión del método de eliminación de Gauss y convierte la matriz aumentada del sistema en su forma reducida escalonada.</p>
                
                    <h2>Procedimiento</h2>
                    <ol>
                        <li>Construir la matriz aumentada del sistema de ecuaciones.</li>
                        <li>Usar operaciones elementales de fila (intercambio, multiplicación y suma/resta de filas) para convertir la matriz aumentada en una matriz identidad en el lado izquierdo.</li>
                        <li>Los valores resultantes en el lado derecho corresponden a las soluciones del sistema.</li>
                    </ol>
                
                    <h2>Ventajas</h2>
                    <ul>
                        <li>Proporciona una solución directa al sistema de ecuaciones lineales.</li>
                        <li>También puede calcular la inversa de una matriz en un solo proceso.</li>
                    </ul>
                
                    <h2>Limitaciones</h2>
                    <ul>
                        <li>Es computacionalmente costoso para sistemas grandes.</li>
                        <li>La precisión puede verse afectada en caso de números muy pequeños o muy grandes.</li>
                    </ul>
                
                    <h2>Aplicaciones</h2>
                    <p>Se utiliza en álgebra lineal aplicada, ingeniería y ciencias para resolver sistemas de ecuaciones lineales y encontrar matrices inversas en modelos matemáticos y simulaciones.</p>
                </body>
                </div>
                <button id="regresar-g-j" class="boton">REGRESAR</button>
                <button id="siguiente-g-j" class="boton">SIGUIENTE</button>
            </div>
        </section>
        <section id="gauss-jordan-2">
            <div class="metodos-2">
                <h2>GAUSS-JORDAN</h2>
                <div align="justify">
                    <p>Instrucciones: Ingresa el orden de la matriz, depués oprime "Crear Mátriz" e ingresa el valor de los coeficientes. Por último presiona "Resolver".</p>            
                    <p>Nota: El valor del elemento Pivote no puede ser 0.</p>
                </div>
                <label for="orden-1">Orden de  la Matiz: </label>
                <input type="text" id="orden-1" class="inter">
                <br>
                <br>
                <button id="crear-matriz" class="boton-r">Crear Mátriz</button>
                <br>
                <br>
                <div id="matriz-gj"></div>
                <br>    
                <section id="section-resolver-gj">
                    <button id="resolver-gj" class="boton-r">Resolver</button>
                </section>
                <br>
                <br>
                <section id="resultado-gj"><p>Los resultados son: </p><div id="r-gj"></div></section>
                <br>
                <br>
                <button id="regresar-g-j-2" class="boton">REGRESAR</button>
                <button id="salir-5" class="boton">SALIR</button>
            </div>
        </section>
        <section id="jacobi-1">
            <div class="metodos-1">
                <h1>Método de Jacobi</h1>
                <div align="justify">
                    <p>El método de Jacobi es un algoritmo iterativo utilizado para resolver sistemas de ecuaciones lineales de la forma \( Ax = b \). Es particularmente útil para matrices dispersas y sistemas grandes, siempre que la matriz \( A \) sea diagonalmente dominante o simétrica positiva definida.</p>
                
                    <h2>Fórmula</h2>
                    <p>La fórmula general para actualizar cada componente \( x_i^{(k+1)} \) en la \( k \)-ésima iteración es:</p>
                    <p>
                        \[
                        x_i^{(k+1)} = \frac{1}{a_{ii}} \left( b_i - \sum_{j \neq i} a_{ij} x_j^{(k)} \right)
                        \]
                    </p>
                
                    <h2>Pasos</h2>
                    <ol>
                        <li>Inicializar un vector \( x^{(0)} \) con valores aproximados.</li>
                        <li>Reemplazar cada \( x_i \) usando la fórmula iterativa.</li>
                        <li>Repetir hasta que la diferencia entre iteraciones consecutivas sea menor que un valor de tolerancia predefinido.</li>
                    </ol>
                
                    <h2>Ventajas</h2>
                    <ul>
                        <li>Sencillo de implementar y adecuado para sistemas dispersos.</li>
                        <li>Permite paralelismo, ya que cada ecuación se resuelve de forma independiente.</li>
                    </ul>
                
                    <h2>Limitaciones</h2>
                    <ul>
                        <li>Puede no converger si la matriz no es diagonalmente dominante o simétrica positiva definida.</li>
                        <li>Convergencia más lenta que otros métodos, como el de Gauss-Seidel.</li>
                    </ul>
                
                    <h2>Aplicaciones</h2>
                    <p>El método de Jacobi se usa en simulaciones numéricas, análisis de estructuras y problemas de física computacional que involucran sistemas de ecuaciones grandes y dispersos.</p>
                </div>
                <button id="regresar-j" class="boton">REGRESAR</button>
                <button id="siguiente-j" class="boton">SIGUIENTE</button>
            </div>
        </section>
        <section id="jacobi-2">
            <div class="metodos-2">
                <h2>JACOBI</h2>
                <div align="justify">
                    <p>Instrucciones: Ingresa el orden de la matriz a resolver, escribe los coeficientes de cada variable y oprime resolver.</p>
                    <p>Nota: El Método garantizará convergencia a la solución cuando la matriz \(A\) tenga diagonal dominante, osea \(a_{ii}\geq a_{ij}, i\neq j, a\in A\)</p>
                    <div align="center">                            
                        <label for="orden-2">Orden de la Matriz: </label>
                        <input type="text" id="orden-2" class="inter">
                        <br>
                        <br>
                        <button id="crear-matriz-2" class="boton-r">Crear Matriz</button>
                        <br>
                        <br>
                        <div id="matriz-j">
                        </div>
                        <br>
                        <br>
                        <section id="section-resolver-j">
                            <button id="resolver-jacobi" class="boton-r">Resolver</button>
                        </section>
                        <br>
                        <br>
                        <div id="r-j"></div>
                        <div id="tabla-jacobi"></div>
                        <br>
                        <br>
                    </div>
                </div>
                <button id="regresar-j-2" class="boton">REGRESAR</button>
                <button id="salir-6" class="boton">SALIR</button>
            </div>
        </section>
        <section id="gauss-seidel-1">
            <div class="metodos-1">
                <h1>Método de Gauss-Seidel</h1>
                <div align="justify">
                    <p>El método de Gauss-Seidel es un algoritmo iterativo para resolver sistemas de ecuaciones lineales de la forma \( Ax = b \). Es una variante del método de Jacobi que utiliza los valores actualizados de \( x \) en cada iteración para acelerar la convergencia.</p>
                
                    <h2>Fórmula</h2>
                    <p>La fórmula general para actualizar \( x_i^{(k+1)} \) es:</p>
                    <p>
                        \[
                        x_i^{(k+1)} = \frac{1}{a_{ii}} \left( b_i - \sum_{j < i} a_{ij} x_j^{(k+1)} - \sum_{j > i} a_{ij} x_j^{(k)} \right)
                        \]
                    </p>
                
                    <h2>Pasos</h2>
                    <ol>
                        <li>Inicializar un vector \( x^{(0)} \) con valores aproximados.</li>
                        <li>Actualizar \( x_i \) en cada iteración usando los valores ya calculados en la misma iteración para \( j < i \).</li>
                        <li>Repetir hasta que la diferencia entre iteraciones consecutivas sea menor que un valor de tolerancia predefinido.</li>
                    </ol>
                
                    <h2>Ventajas</h2>
                    <ul>
                        <li>Convergencia más rápida que el método de Jacobi en la mayoría de los casos.</li>
                        <li>Requiere menos memoria, ya que los valores de \( x \) se actualizan en su lugar.</li>
                    </ul>
                
                    <h2>Limitaciones</h2>
                    <ul>
                        <li>Puede no converger si la matriz no es diagonalmente dominante o simétrica positiva definida.</li>
                        <li>No es tan adecuado para sistemas donde las matrices son muy grandes y dispersas.</li>
                    </ul>
                    
                    <h2>Aplicaciones</h2>
                    <p>El método de Gauss-Seidel se utiliza en simulaciones numéricas, ingeniería estructural y análisis de circuitos eléctricos, donde se necesitan aproximaciones rápidas de soluciones de sistemas lineales.</p>
                </div>
                <button id="regresar-g-s" class="boton">REGRESAR</button>
                <button id="siguiente-g-s" class="boton">SIGUIENTE</button>
            </div>
        </section>
        <section id="gauss-seidel-2">
            <div class="metodos-2">
                <h2>GAUSS SEIDEL</h2>
                <div align="justify">
                    <p>Instrucciones: Ingresa el orden de la matriz, presiona el boton "Crear Matriz" y luego oprime "Resolver"</p>
                    <p>Nota: La diagonal debe ser estrictamente dominante:</p> 
                    <div align="center"> 
                        \(|a_{ii}| \geq \sum_{j \neq i}^{n}|a_{ij}|, a\in A \)
                        <br>
                        <br>
                        <label for="orden-3">Orden de la Matriz: </label>
                        <input type="text" id="orden-3" class="inter">
                        <br>
                        <br>
                        <button id="crear-matriz-3" class="boton-r">Crear Matriz</button>
                        <br>
                        <br>
                        <div id="matriz-gs">
                        </div>
                        <br>
                        <br>
                        <section id="section-resolver-gs">
                            <button id="resolver-gauss-seidel" class="boton-r">Resolver</button>
                        </section>
                        <br>
                        <br>
                        <div id="r-gs"></div>
                        <div id="tabla-gauss-seidel"></div>
                        <br>
                        <br>
                    </div>                                    
                </div>
                <button id="regresar-g-s-2" class="boton">REGRESAR</button>
                <button id="salir-7" class="boton">SALIR</button>
            </div>
        </section>
    </div>
    <!--UNIDAD IV-->
    <div class="unidad-4">
        <section id="unidad-4-introduccion">
            <div class="introducciones">
                <div align="center"><h1>Factorización LU y sus Aplicaciones</h1></div>                
                <p>La factorización LU (o descomposición LU) es una técnica matemática que permite descomponer una matriz cuadrada \( A \) en el producto de dos matrices:</p>
                <p>
                    \[
                    A = L \cdot U
                    \]
                    donde:
                    <ul>
                        <li>\( L \) es una matriz triangular inferior (con unos en la diagonal principal).</li>
                        <li>\( U \) es una matriz triangular superior.</li>
                    </ul>
                </p>
                <h3>Características</h3>
                <ul>
                    <li>Es aplicable a matrices cuadradas no singulares (\( \det(A) \neq 0 \)).</li>
                    <li>Puede requerir pivoteo parcial o completo para garantizar estabilidad numérica.</li>
                    <li>Reduce el costo computacional para sistemas lineales con múltiples vectores independientes \( \mathbf{b} \).</li>
                </ul>
                <h3>Proceso de Factorización</h3>
                <p>La factorización LU se obtiene a través de métodos como la eliminación de Gauss:</p>
                <ol>
                    <li>Aplicar operaciones elementales para transformar la matriz \( A \) en una matriz triangular superior \( U \).</li>
                    <li>Registrar los factores multiplicativos de estas operaciones en una matriz triangular inferior \( L \).</li>
                </ol>
                <p>Si se necesita mayor estabilidad numérica, se emplea pivoteo, lo que introduce una matriz de permutación \( P \):</p>
                <p>
                    \[
                    P \cdot A = L \cdot U
                    \]
                </p>
                <h3>Aplicaciones</h3>
                <p>La factorización LU tiene múltiples aplicaciones en matemáticas aplicadas y ciencias de la computación:</p>
                <ul>
                    <li><strong>Resolución de sistemas de ecuaciones lineales:</strong> Para resolver \( A \mathbf{x} = \mathbf{b} \), primero se calcula \( L \cdot U = A \), luego se resuelve:
                        <ol>
                            <li>\( L \mathbf{y} = \mathbf{b} \) (sustitución progresiva).</li>
                            <li>\( U \mathbf{x} = \mathbf{y} \) (sustitución regresiva).</li>
                        </ol>
                    </li>
                    <li><strong>Inversión de matrices:</strong> La factorización LU permite calcular la inversa de \( A \) resolviendo \( A \mathbf{x}_i = \mathbf{e}_i \), donde \( \mathbf{e}_i \) son los vectores de la base canónica.</li>
                    <li><strong>Análisis numérico:</strong> Optimiza el cálculo para matrices grandes y es un paso clave en algoritmos como los de factorización QR o SVD.</li>
                </ul>
                <br>
                <div align="center">
                    <button id="regresar-u-4-1" class="boton">REGRESAR</button>
                    <button id="siguiente-u-4-1" class="boton">SIGUIENTE</button>
                </div>                
            </div>            
        </section>
        <section id="unidad-4-menu">
            <div class="menu" align="center">
                <h2>Menú</h2>
                <h3>Factorización LU y sus aplicaciones</h3>
                <div align="center">
                    <br>
                    <br>
                    <br>
                    <br>
                    <table border="0" cellspacing="0" width="600px">
                        <tr>
                            <td align="center">
                                <label for="doolittle" class="radio">DOOLITTLE</label>
                                <input type="radio" id="doolittle" name="enl" class="radio">
                            </td>
                            <td align="center">
                                <label for="cholesky" class="radio">CHOLESKY</label>
                                <input type="radio" id="cholesky" name="enl" class="radio">
                            </td>
                        </tr>
                    </table>     
                    <br>
                    <br>                    
                    <br>                
                </div>
                <br>
                <br>
                <button id="regresar-u-4-2" class="boton">REGRESAR</button>
                <button id="siguiente-u-4-2" class="boton">SELECCIONAR</button>
            </div>                    
        </section>
        <section id="doolittle-1">
            <div class="metodos-1" align="center">
                <h1>Método de Doolittle</h1>
                <div align="justify">
                    <p>El método de Doolittle es un procedimiento utilizado para resolver sistemas de ecuaciones lineales mediante la factorización de una matriz \( A \) en el producto de dos matrices: una matriz triangular inferior \( L \) y una matriz triangular superior \( U \), es decir, \( A = LU \).</p>
                
                    <h2>Procedimiento</h2>
                    <ol>
                        <li>Reescribir la matriz \( A \) como el producto \( L \cdot U \), donde \( L \) tiene unos en la diagonal principal.</li>
                        <li>Calcular las entradas de \( L \) y \( U \) de forma iterativa utilizando sustituciones hacia adelante y hacia atrás.</li>
                        <li>Resolver el sistema \( Ax = b \) en dos pasos:
                            <ul>
                                <li>Primero, resolver \( Ly = b \) usando sustitución hacia adelante.</li>
                                <li>Luego, resolver \( Ux = y \) usando sustitución hacia atrás.</li>
                            </ul>
                        </li>
                    </ol>
                
                    <h2>Ventajas</h2>
                    <ul>
                        <li>Permite resolver múltiples sistemas con la misma matriz \( A \) cambiando solo el vector \( b \).</li>
                        <li>Reduce el costo computacional al dividir el problema en pasos más simples.</li>
                    </ul>
                
                    <h2>Limitaciones</h2>
                    <ul>
                        <li>No siempre es aplicable si la matriz \( A \) es singular o no cuadrada.</li>
                        <li>Pierde precisión en matrices con números muy pequeños o muy grandes debido a errores de redondeo.</li>
                    </ul>
                
                    <h2>Aplicaciones</h2>
                    <p>Se usa en álgebra lineal numérica para resolver sistemas de ecuaciones, calcular inversas de matrices y determinar determinantes de matrices grandes.</p>
                </div>
                <div align="center">
                    <button id="regresar-c" class="boton">REGRESAR</button>
                    <button id="siguiente-c" class="boton">SIGUIENTE</button>
                </div>
            </div>
        </section>
        <section id="doolittle-2">
            <div class="metodos-2" align="center">
                <h2>DOOLITTLE</h2>
                <div align="justify">
                    <p>instrucciones: Ingresa el orden del la matriz \(A\) y presiona "Crear matriz", luego ingresa el valor de los coeficientes, por último presiona "Resolver". </p>                    
                    <div align="center"> 
                        <br>
                        <br>
                        <label for="orden-4">Orden de la Matriz: </label>
                        <input type="text" id="orden-4" class="inter">
                        <br>
                        <br>
                        <button id="crear-matriz-4" class="boton-r">Crear Matriz</button>
                        <br>
                        <br>
                        <div id="matriz-d">
                        </div>
                        <br>
                        <br>
                        <section id="section-resolver-d">
                            <button id="resolver-doolittle" class="boton-r">Resolver</button>
                        </section>
                        <br>
                        <div class="LU">
                            <div id="matriz-l-d"></div>                        
                            <div id="matriz-u-d"></div>
                            <div id="vector-z-d"></div>
                        </div>                    
                        <br>
                        <br>
                        <div id="r-d"></div>
                        <br>
                        <br>
                    </div> 
                </div>
                <button id="regresar-c-2" class="boton">REGRESAR</button>
                <button id="salir-8" class="boton">SALIR</button>
            </div>         
        </section>
        <section id="cholesky-1">
            <div class="metodos-1" align="center">
                <h1>Método de Cholesky</h1>
                <div align="justify">
                    <p>El método de Cholesky es una técnica de factorización utilizada para resolver sistemas de ecuaciones lineales. Descompone una matriz simétrica y definida positiva \( A \) en el producto de una matriz triangular inferior \( L \) y su traspuesta \( L^T \), es decir, \( A = LL^T \).</p>                
                    <h2>Procedimiento</h2>
                    <ol>
                        <li>Comprobar que la matriz \( A \) es simétrica y definida positiva.</li>
                        <li>Calcular los elementos de \( L \) utilizando la fórmula:
                            \[
                            l_{ii} = \sqrt{a_{ii} - \sum_{k=1}^{i-1} l_{ik}^2}
                            \]
                            y para \( i \neq j \):
                            \[
                            l_{ij} = \frac{1}{l_{jj}} \left( a_{ij} - \sum_{k=1}^{j-1} l_{ik} l_{jk} \right).
                            \]
                        </li>
                        <li>Resolver el sistema \( Ax = b \) mediante:
                            <ul>
                                <li>Sustitución hacia adelante para \( Ly = b \).</li>
                                <li>Sustitución hacia atrás para \( L^T x = y \).</li>
                            </ul>
                        </li>
                    </ol>                
                    <h2>Ventajas</h2>
                    <ul>
                        <li>Es más eficiente que otros métodos como Doolittle para matrices simétricas y definidas positivas.</li>
                        <li>Reduce el costo computacional al trabajar con la mitad de los elementos de la matriz.</li>
                    </ul>                
                    <h2>Limitaciones</h2>
                    <ul>
                        <li>Solo es aplicable a matrices simétricas y definidas positivas.</li>
                        <li>Puede ser inexacto si la matriz no cumple estas propiedades.</li>
                    </ul>                
                    <h2>Aplicaciones</h2>
                    <p>El método de Cholesky se utiliza en optimización, álgebra lineal numérica y análisis estadístico, especialmente en problemas que involucran matrices grandes y simétricas, como las covarianzas.</p>
                </div>
                <button id="regresar-csky" class="boton">REGRESAR</button>
                <button id="siguiente-csky" class="boton">SIGUIENTE</button>
            </div>            
        </section>
        <section id="cholesky-2">
            <div class="metodos-2" align="center">
                <h2>CHOLESKY</h2>
                <div align="justify">
                    <p>Instrucciones: Ingresa el orden de la matriz, presiona "Crear Matriz" e ingresa el valor de los ceficientes. Luego oprime "Resolver".</p>
                    <p>Nota: Para poder aplicar el método será necesario que la matriz cumpla las condiciones:</p>
                    <ol>
                        <li>Simétrica: \(A^T = A\)</li>
                        <li>Definida Positiva: \(\vec{x}^T A \vec{x} > 0\)</li>
                    </ol>
                </div>
                <br>
                <br>
                <label for="orden-5">Orden de la Matriz: </label>
                <input type="text" id="orden-5" class="inter">
                <br>
                <br>
                <button id="crear-matriz-5" class="boton-r">Crear Matriz</button>
                <br>
                <br>
                <div id="matriz-c">
                </div>
                <br>
                <br>
                <section id="section-resolver-c">
                    <button id="resolver-cholesky" class="boton-r">Resolver</button>
                </section>
                <br>
                <div class="LU">
                    <div id="matriz-l-c"></div>                        
                    <div id="matriz-u-c"></div>
                </div>                    
                <br>
                <br>
                <div class="LU">
                    <div id="vector-z-c"></div>
                    <div id="r-c"></div>
                </div>                
                <br>
                <br>
                <button id="regresar-csky-2" class="boton">REGRESAR</button>
                <button id="salir-9" class="boton">SALIR</button>
            </div>            
        </section>
    </div>
    <div class="unidad-5">
        <section id="unidad-5-introduccion">
            <div class="introducciones">
                <div align="center"><h1>Cálculo de Valores y Vectores Propios</h1></div>                
                <p>Los valores propios y vectores propios son conceptos fundamentales en álgebra lineal y tienen aplicaciones extensas en diversas disciplinas, como física, economía, ingeniería y ciencias de datos. Para una matriz cuadrada \( A \), un valor propio \( \lambda \) y un vector propio \( \mathbf{v} \) satisfacen la ecuación:</p>
                <p>
                    \[
                    A \mathbf{v} = \lambda \mathbf{v}
                    \]
                    donde:
                    <ul>
                        <li>\( \lambda \) es un escalar, llamado valor propio.</li>
                        <li>\( \mathbf{v} \) es un vector no nulo, llamado vector propio.</li>
                    </ul>
                </p>

                <h3>Cálculo de Valores Propios</h3>
                <p>Para encontrar los valores propios de una matriz \( A \), se resuelve el problema característico:</p>
                <p>
                    \[
                    \det(A - \lambda I) = 0
                    \]
                    donde \( I \) es la matriz identidad. Esta ecuación genera un polinomio característico, cuyos raíces son los valores propios de \( A \).
                </p>

                <h3>Cálculo de Vectores Propios</h3>
                <p>Una vez que los valores propios \( \lambda \) han sido determinados, los vectores propios se calculan resolviendo el sistema lineal:</p>
                <p>
                    \[
                    (A - \lambda I) \mathbf{v} = 0
                    \]
                </p>
                <p>Este sistema puede tener múltiples soluciones no triviales, lo que implica que los vectores propios asociados a un valor propio forman un subespacio (espacio propio).</p>

                <h3>Aplicaciones</h3>
                <p>Los valores y vectores propios tienen múltiples aplicaciones prácticas, incluyendo:</p>
                <ul>
                    <li><strong>Dinámica de sistemas:</strong> Análisis de estabilidad y oscilaciones en sistemas físicos y económicos.</li>
                    <li><strong>Reducción de dimensionalidad:</strong> Técnicas como el Análisis de Componentes Principales (PCA) utilizan valores propios para identificar las direcciones de máxima varianza en los datos.</li>
                    <li><strong>Resolución de ecuaciones diferenciales:</strong> Los valores propios de operadores diferenciales lineales ayudan a determinar soluciones generales.</li>
                    <li><strong>Similitud matricial:</strong> La diagonalización de matrices simplifica cálculos exponenciales y otras operaciones matriciales.</li>
                </ul>
                <div align="center">
                    <button id="regresar-u-5-1" class="boton">REGRESAR</button>
                    <button id="siguiente-u-5-1" class="boton">SIGUIENTE</button>
                </div>                
            </div>            
        </section>
        <section id="unidad-5-menu">
            <div class="menu" align="center">
                <h2>Menú</h2>
                <h3>Cálculo de valores y vectores propios</h3>
                <br>
                <br>
                <br>
                <br>
                <div align="left">
                    <table border="0" cellspacing="0" align="center" width="600px">
                        <tr>
                            <td align="center">
                                <label for="potencia" class="radio">POTENCIA</label>
                                <input type="radio" id="potencia" name="enl" class="radio">  
                            </td>
                            <td align="center">
                                <label for="potencia-inversa" class="radio">POTENCIA-INVERSA</label>
                                <input type="radio" id="potencia-inversa" name="enl" class="radio">
                            </td>
                        </tr>
                    </table>                                                                                          
                </div>
                <br>
                <br>
                <br>
                <br>
                <button id="regresar-u-5-2" class="boton">REGRESAR</button>
                <button id="seleccionar-u-5-2" class="boton">SELECCIONAR</button>
            </div>                        
        </section>
        <section id="potencia-1">
            <div class="metodos-1" align="center">
                <h3>Método de la Potencia</h3>
                <div align="justify">
                    <p>
                    El <strong>método de la potencia</strong> es un algoritmo iterativo utilizado para calcular el 
                    <em>autovalor dominante</em> y su correspondiente <em>autovector</em> de una matriz cuadrada \( A \).
                    </p>
                    <h4>Descripción</h4>
                    <p>
                    Dado un vector inicial no nulo \( x^{(0)} \), el método genera una sucesión de vectores mediante la iteración:
                    </p>
                    <p style="text-align: center;">
                    \( x^{(k+1)} = A x^{(k)} \),  \( x^{(k+1)} \gets \frac{x^{(k+1)}}{\|x^{(k+1)}\|} \),
                    </p>
                    <p>
                    donde \( \|x\| \) es una norma (usualmente, la norma euclidiana). Esta normalización evita el crecimiento ilimitado de \( x^{(k)} \).
                    </p>
                    <h4>Convergencia</h4>
                    <p>
                    Si \( A \) tiene un autovalor dominante \( \lambda_1 \) (es decir, \( |\lambda_1| > |\lambda_i| \) para todos los \( i \neq 1 \)), el método converge a un vector paralelo al autovector asociado a \( \lambda_1 \).
                    </p>
                    <h4>Ventajas</h4>
                    <ul>
                    <li>Simplicidad de implementación.</li>
                    <li>Computacionalmente eficiente para matrices grandes y dispersas.</li>
                    </ul>
                    <h4>Limitaciones</h4>
                    <ul>
                    <li>No converge si \( A \) no tiene un autovalor dominante.</li>
                    <li>Puede ser sensible al vector inicial \( x^{(0)} \).</li>
                    </ul>
                </div>
                <button id="regresar-p" class="boton">REGRESAR</button>
                <button id="siguiente-p" class="boton">SIGUIENTE</button>
            </div>            
        </section>
        <section id="potencia-2">
            <div class="metodos-2" align="center">
                <h2>POTENCIA</h2>
                <div align="justify">
                    <p>Instrucciones: Ingresa el orden de la matriz y presiona "Crear Matriz". Luego ingesa el valor de los coeficientes y un vector inicial. El método calculará el valor propio dominante y el vector propio asociado al valor propio dominante.</p>                    
                </div>
                <br>
                <br>
                <label for="orden-6">Orden de la Matriz: </label>
                <input type="text" id="orden-6" class="inter">
                <br>
                <br>
                <button id="crear-matriz-6" class="boton-r">Crear Matriz</button>
                <br>
                <br>
                <div id="matriz-p" class="vector"></div>
                <br>
                <br>
                <div id="vector-p" class="vector"></div>
                <br>
                <br>
                <section id="section-resolver-p">
                    <button id="resolver-potencia" class="boton-r">Resolver</button>
                </section>
                <br>
                <br>
                <div id="eigenvalor-p"></div>
                <br>
                <div id="eigenvector-p"></div>
                <br>
                <div id="tabla-p"></div>
                <br>
                <br>
                <button id="regresar-p-2" class="boton">REGRESAR</button>
                <button id="salir-10" class="boton">SALIR</button>
            </div>            
        </section>
        <section id="potencia-inversa-1">
            <div class="metodos-1" align="center">
                <h1>Método de la Potencia Inversa</h1>
                <div align="justify">
                    <p>
                    El <strong>método de la potencia inversa</strong> es una variante del método de la potencia, utilizada para encontrar el 
                    <em>autovalor más pequeño en magnitud</em> de una matriz cuadrada \( A \) y su correspondiente <em>autovector</em>.
                    </p>
                    
                    <h2>Descripción</h2>
                    <p>
                    Dado un vector inicial no nulo \( x^{(0)} \), el método genera una sucesión de vectores resolviendo iterativamente un sistema lineal:
                    </p>
                    <p style="text-align: center;">
                    \( A y^{(k)} = x^{(k)}, \quad x^{(k+1)} = \frac{y^{(k)}}{\|y^{(k)}\|} \),
                    </p>
                    <p>
                    donde \( \|x\| \) es una norma (usualmente, la norma euclidiana). Esto equivale a aplicar el método de la potencia a la matriz \( A^{-1} \), destacando los autovalores más cercanos a cero.
                    </p>
                    
                    <h2>Convergencia</h2>
                    <p>
                    Si \( \mu_1 \) es el autovalor de \( A \) más pequeño en magnitud (es decir, \( |\mu_1| < |\mu_i| \) para \( i \neq 1 \)), el método converge a un vector paralelo al autovector asociado a \( \mu_1 \).
                    </p>
                    
                    <h2>Ventajas</h2>
                    <ul>
                    <li>Permite calcular el autovalor más pequeño en magnitud, útil para problemas específicos.</li>
                    <li>Es efectivo para matrices grandes y dispersas.</li>
                    </ul>
                    
                    <h2>Limitaciones</h2>
                    <ul>
                    <li>Requiere resolver un sistema lineal en cada iteración, lo que puede ser costoso computacionalmente.</li>
                    <li>Sensible a la elección del vector inicial \( x^{(0)} \).</li>
                    <li>No converge si \( A \) es singular.</li>
                    </ul>
                    
                    <h2>Notas Adicionales</h2>
                    <p>
                    El método puede combinarse con desplazamientos espectrales para calcular autovalores cercanos a un valor dado \( \sigma \) 
                    al aplicar el método de potencia inversa a \( (A - \sigma I)^{-1} \).
                    </p>
                </div>
                <button id="regresar-p-i" class="boton">REGRESAR</button>
                <button id="siguiente-p-i" class="boton">SIGUIENTE</button>
            </div>            
        </section>
        <section id="potencia-inversa-2">
            <div class="metodos-2" align="center">
                <h2>POTENCIA-INVERSA</h2>
                <div align="justify">
                    <p>Instrucciones: Ingresa el orden de la matriz y presiona "Crear Matriz". Luego ingesa el valor de los coeficientes y un vector inicial. El método calculará el valor propio menor y el vector propio asociado al valor propio menor.</p>                    
                </div>
                <br>
                <br>
                <label for="orden-7">Orden de la Matriz: </label>
                <input type="text" id="orden-7" class="inter">
                <br>
                <br>
                <button id="crear-matriz-7" class="boton-r">Crear Matriz</button>
                <br>
                <br>
                <div id="matriz-p-i" class="vector"></div>
                <br>
                <br>
                <div id="vector-p-i" class="vector"></div>
                <br>
                <br>
                <section id="section-resolver-p-i">
                    <button id="resolver-potencia-inversa" class="boton-r">Resolver</button>
                </section>
                <br>
                <br>
                <div id="eigenvalor-p-i"></div>
                <br>
                <div id="eigenvector-p-i"></div>
                <br>
                <div id="tabla-p-i"></div>
                <br>
                <br>
                <button id="regresar-p-i-2" class="boton">REGRESAR</button>
                <button id="salir-11" class="boton">SALIR</button>
            </div>            
        </section>
    </div>
    <!--SALIDA!!!!!-->
    <section id="salida">
        <div class="salida" align="center">
            <h1>¡¡¡Gracias por utilizar el programa!!!</h1>            
            <img src="despedida.png" alt="">
            <div align="justify">
                <h2>Referencias: </h2>
                <ol>
                    <li>
                        <p><strong>Burden, R. L., & Faires, J. D. (2011). </strong><em>Numerical Analysis</em> (9th ed.). Brooks/Cole, Cengage Learning.</p>
                    </li>
                    <li>
                        <p><strong>Chapra, S. C., & Canale, R. P. (2010). </strong><em>Numerical Methods for Engineers</em> (6th ed.). McGraw-Hill Education.</p>
                    </li>
                    <li>
                        <p><strong>Kincaid, D., & Cheney, W. (2002). </strong><em>Numerical Analysis: Mathematics of Scientific Computing</em> (3rd ed.). Brooks/Cole.</p>
                    </li>
                </ol>
            </div>            
        </div>
    </section>
    <audio id="sonido-salida">
        <source type="audio/wav" src="./99636__tomlija__small-crowd-yelling-yeah.wav">
    </audio>
    <audio id="audio-2">
        <source type="audio/wav" src="./340362__deleted_user_5205523__medium-sized-indoor-crowd-clapping-outro.wav">
    </audio>
</body>
</html>